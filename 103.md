>"I give you a new commandment, that you love one another. Just as I have loved you, you also should love one another. By this everyone will know that you are my disciples, if you have love for one another."(JOHN14:34-35)

#除法

除法啰嗦，不仅是Python。

更何况，Python 2和Python 3中的除法还不一样。

更啰嗦了。

所以，读者不要因为我单独列出本节而有怨言。

##整数除以整数

进入Python 2交互模式之后，练习下面的运算：

    >>> 2 / 5
    0
    >>> 2.0 / 5
    0.4
    >>> 2 / 5.0
    0.4
    >>> 2.0 / 5.0
    0.4

看到没有？Python 2 中的麻烦出来了，按照数学运算，以上四个运算结果都应该是0.4。但我们看到的后三个符合，第一个居然结果是0。why?

因为，在Python 2里面有一个规定，像2/5中的除法这样，是要取整（就是去掉小数，但不是四舍五入）。2除以5，商是0（整数），余数是2（整数）。那么如果用这种形式：2/5，计算结果就是商那个整数。或者可以理解为：**整数除以整数，结果是整数（商）**。

比如：

    >>> 5 / 2
    2
    >>> 7 / 2
    3
    >>> 8 / 2
    4
    
**注意：**得到是商（整数）,而不是得到含有小数位的结果再通过“四舍五入”取整。例如：5/2，得到的是商2，余数1，最终`5 / 2 = 2`。并不是对2.5进行四舍五入。

这就是Python 2中规定的原则，不用琢磨为什么了。

在Python 3.x中，规则又变了，如果`1/2`，结果就是0.5，也就是说Python 3中的除法是真正的除法了，要取整，只能用`1//2`的方式，即`1//2=0`。

这就是规则，人为规定的，使用者只有顺从，就如同足球比赛的规则一样。

在Python 3中，演示几个除法：

    >>> 5 / 2
    2.5
    >>> 7 / 2
    3.5
    >>> 8 / 2
    4.0

要想实现类似Python 2中那样的取整除法，Python 3也是可以，这么做：

    >>> 5 // 2
    2
    
##浮点数与整数相除

这里还是先讨论Python 2中的“浮点数与整数相除”，其含义是：

假设：x除以y。其中 x 可能是整数，也可能是浮点数；y可能是整数，也可能是浮点数。

出结论之前，还是先做实验：

    >>> 9.0 / 2
    4.5
    >>> 9 / 2.0
    4.5
    >>> 9.0 / 2.0
    4.5
    
	>>> 8.0 / 2
    4.0
    >>> 8 / 2.0
    4.0
    >>> 8.0 / 2.0
    4.0

归纳，得到规律：**不管是被除数还是除数，只要有一个数是浮点数，结果就是浮点数。**所以，如果相除的结果有余数，也不会像前面一样了，而是要返回一个浮点数，这就跟在数学上学习的结果一样了。

再说Python 3。

前面已经看到，`5 / 2`，得到的就是浮点数`2.5`；现在，如果当除数或者被除数，有一个或者两个都是浮点数，结果当然还是浮点数。

    >>> 5.0 / 2
    2.5

看来Python 3的一致性比较好。

但不管是Python 2还是Python 3，都有这种情况：

    >>> 10.0 / 3
    3.3333333333333335

这个是不是就有点搞怪了，按照数学知识，应该是3.33333...，后面是3的循环了。那么你的计算机就停不下来了，满屏都是3。为了避免这个，Python武断终结了循环，但是，可悲的是没有按照“四舍五入”的原则终止。当然，还会有更奇葩的出现：

    >>> 0.1 + 0.2
    0.30000000000000004
    >>> 0.1 + 0.1 - 0.2
    0.0
    >>> 0.1 + 0.1 + 0.1 - 0.3
    5.551115123125783e-17
    >>> 0.1 + 0.1 + 0.1 - 0.2
    0.10000000000000003

越来越糊涂了，为什么computer姑娘在计算这么简单的问题上，如此糊涂了呢？不是computer姑娘糊涂，她依然冰雪聪明。

原因在于十进制和二进制的转换上，computer姑娘用的是二进制进行计算，上面的例子中，我们输入的是十进制，她就要把十进制的数转化为二进制，然后再计算。但是，在转化中，浮点数转化为二进制，就出问题了。

例如十进制的0.1，转化为二进制是：0.0001100110011001100110011001100110011001100110011...

也就是说，转化为二进制后，不会精确等于十进制的0.1。同时，计算机存储的位数是有限制的，所以，就出现上述现象了。

这种问题不仅仅是Python中有，所有支持浮点数运算的编程语言都会遇到，它不是Python的bug。

明白了问题原因，怎么解决呢？就Python的浮点数运算而言，大多数机器上每次计算误差不超过 2**53 分之一。对于大多数任务这已经足够了，但是要在心中记住这不是十进制算法，每个浮点数计算可能会带来一个新的舍入错误。

一般情况下，只要简单地将最终显示的结果用“四舍五入”到所期望的十进制位数，就会得到期望的最终结果。

但是，不是什么地方都能“差不多”的。需要精确，用什么方法解决？

可以使用 decimal 模块，它实现的十进制运算适合会计方面的应用和高精度要求的应用。

另外 fractions 模块支持另外一种形式的运算，它实现的运算基于有理数（因此像1/3这样的数字可以精确地表示）。

最高要求则可是使用numPy 包和其它用于数学和统计学的包。

列出这些东西，仅仅是让读者能明白，解决问题的方式很多，不必担心。

关于无限循环小数问题，有一个链接推荐给诸位，它不是想象的那么简单呀。请阅读：[维基百科的词条：0.999...](http://zh.wikipedia.org/wiki/0.999%E2%80%A6)，会不会有深入体会呢？

>补充一个资料，供有兴趣的朋友阅读：[浮点数算法：争议和限制](https://docs.python.org/2/tutorial/floatingpoint.html#tut-fp-issues)

Python总会要提供多种解决问题的方案的，这是她的风格。

并且常常有现成的“轮子”可是使用。

##引用模块解决除法

Python之所以受人欢迎，一个很重重要的原因，就是轮子多。这是比喻啦。就好比你要跑的快，怎么办？光天天练习跑步是不行滴，要用轮子。找辆自行车，就快了很多。还嫌不够快，再换电瓶车，再换汽车，再换高铁...反正你可以选择的很多。但是，这些让你跑的快的东西，多数不是你自己造的，是别人造好了，你来用。甚至两条腿也是感谢父母恩赐。正是因为轮子多，可以选择的多，就可以以各种不同速度享受了。

轮子是人类伟大的发明。

Python就是这样，有各种轮子，我们只需要用。只不过那些轮子在Python里面的名字不叫自行车、汽车，叫做“模块”或者“库”，有人承接别的语言的名称，叫做“类库”、“类”。不管叫什么名字吧。就是别人造好的东西我们拿过来使用。

怎么用？可以通过两种形式用：

- 形式1：import module-name。import后面跟空格，然后是模块名称，例如：import os
- 形式2：from module1 import module11。module1是一个大模块，里面还有子模块module11，只想用module11，就这么写了。

不啰嗦了，实验一个：

    >>> from __future__ import division
    >>> 5 / 2
    2.5
    >>> 9 / 2
    4.5
    >>> 9.0 / 2
    4.5
    >>> 9 / 2.0
    4.5

注意了，引用了一个模块之后，再做除法，就不管什么情况，都是得到浮点数的结果了。

当然，上述做法是在Python 2中，因为Python 3中天然如此了，没有必要再为此而`from __future__ import division`。

这就是轮子的力量。

除法的组成有除数、被除数、商和余数，余数也可以单独计算。

##余数

计算`5/2`，商是2，余数是1。

余数怎么得到？在Python中（其实大多数语言也都是），用`%`符号来取得两个数相除的余数.

操作如下，不论Python 2还是Python 3：

    >>> 5 % 2
    1
    >>> 6 % 4
    2
    >>> 5.0 % 2
    1.0

符号：%，就是要得到两个数（可以是整数，也可以是浮点数）相除的余数。

Python不枯燥，因为她多变。

除了使用`%`求余数，还有内建函数`divmod()`——返回的是商和余数。

    >>> divmod(5, 2)  #表示5除以2，返回了商和余数
    (2, 1)
    >>> divmod(9, 2)
    (4, 1)
    >>> divmod(5.0, 2)
    (2.0, 1.0)

同样是不区分版本。

##四舍五入

最后一个了，一定要坚持，的确有点啰嗦了。

要实现四舍五入，很简单，就是内建函数：`round()`

动手试试：

    >>> round(1.234567, 2)
    1.23
    >>> round(1.234567, 3)
    1.235
    >>> round(10.0/3, 4)
    3.3333

如何理解`round()`内建函数的使用？要建立一个好习惯，并且掌握这个好方法：

    >>> help(round)
    Help on built-in function round in module builtins:

    round(...)
        round(number[, ndigits]) -> number
    
        Round a number to a given precision in decimal digits (default 0 digits).
        This returns an int when called with one argument, otherwise the
        same type as the number. ndigits may be negative.

应该能读懂，我相信你。
        
简单吧。越简单的时候，越要小心，当你遇到下面的情况，就有点怀疑了：

    >>> round(1.2345, 3)
    1.234               #应该是：1.235
    >>> round(2.235, 2)
    2.23                #应该是：2.24

哈哈，发现了Python的一个bug，太激动了。

别那么激动，如果真的是bug，这么明显，是轮不到我的。为什么？具体解释看这里，下面摘录官方文档中的一段话：

>**Note:**
>The behavior of round() for floats can be surprising: for example, round(2.675, 2) gives 2.67 instead of the expected 2.68. This is not a bug: it’s a result of the fact that most decimal fractions can’t be represented exactly as a float. See [Floating Point Arithmetic: Issues and Limitations](https://docs.python.org/2/tutorial/floatingpoint.html#tut-fp-issues) for more information.

原来真的轮不到我。归根到底还是浮点数中的十进制转化为二进制惹的祸。

似乎除法的问题到此要结束了，其实远远没有，不过，做为初学者，至此即可。还留下了很多话题，比如如何处理循环小数问题，我肯定不会让有探索精神的朋友失望的，在我的github中有这样一个轮子，如果要深入研究，[可以来这里尝试](https://github.com/qiwsir/algorithm/blob/master/divide.py)。

对于计算，远不止这些，还有一个更好用的工具——math。

------

[总目录](./index.md)&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;[上节：数和四则运算](./102.md)&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;[下节：Math模块和运算优先级](./104.md)

如果你认为有必要打赏我，请通过支付宝：**qiwsir@126.com**,不胜感激。